package ortus.boxlang.runtime.jdbc.drivers;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.sql.SQLException;
import java.sql.Types;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIf;

import ortus.boxlang.compiler.parser.BoxSourceType;
import ortus.boxlang.runtime.BoxRuntime;
import ortus.boxlang.runtime.context.IBoxContext;
import ortus.boxlang.runtime.context.ScriptingRequestBoxContext;
import ortus.boxlang.runtime.jdbc.DataSource;
import ortus.boxlang.runtime.scopes.Key;
import ortus.boxlang.runtime.types.Array;
import ortus.boxlang.runtime.types.IStruct;
import ortus.boxlang.runtime.types.Query;
import ortus.boxlang.runtime.types.QueryColumn;
import ortus.boxlang.runtime.types.QueryColumnType;
import ortus.boxlang.runtime.types.Struct;
import ortus.boxlang.runtime.types.exceptions.DatabaseException;

@EnabledIf( "tools.JDBCTestUtils#hasOracleModule" )
public class OracleDriverTest extends AbstractDriverTest {

	public static DataSource	oracleDatasource;

	protected static Key		datasourceName		= Key.of( "OracleDatasource" );

	protected static IStruct	datasourceConfig	= Struct.of(
	    "username", "system",
	    "password", "123456Password",
	    "host", "localhost",
	    "port", "1521",
	    "driver", "oracle",
	    "serviceName", "XEPDB1"
	);

	@BeforeAll
	public static void setUp() {
		instance = BoxRuntime.getInstance( true );
		IBoxContext setUpContext = new ScriptingRequestBoxContext( instance.getRuntimeContext() );
		oracleDatasource = AbstractDriverTest.setupTestDatasource( instance, setUpContext, datasourceName, datasourceConfig );
		OracleDriverTest.createGeneratedKeyTable( oracleDatasource, setUpContext );
		OracleDriverTest.createStoredProcedure( oracleDatasource, setUpContext );
	}

	@AfterAll
	public static void teardown() throws SQLException {
		IBoxContext tearDownContext = new ScriptingRequestBoxContext( instance.getRuntimeContext() );
		AbstractDriverTest.teardownTestDatasource( tearDownContext, oracleDatasource );
	}

	/**
	 * Override to provide driver-specific datasource name
	 */
	@Override
	String getDatasourceName() {
		return "OracleDatasource";
	}

	public static void createGeneratedKeyTable( DataSource dataSource, IBoxContext context ) {
		try {
			dataSource.execute( "CREATE TABLE generatedKeyTest( id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR2(155))", context );
		} catch ( DatabaseException ignored ) {
		}
	}

	public static void createStoredProcedure( DataSource dataSource, IBoxContext context ) {
		dataSource.execute(
		    """
		    CREATE OR REPLACE PROCEDURE testProcedure (
		    	in1 IN NUMBER DEFAULT 45,
		    	in2 IN NVARCHAR2,
		    	inout1 IN OUT NUMBER,
		    	out1 OUT NVARCHAR2,
		    	cursor1 OUT SYS_REFCURSOR,
		    	cursor2 OUT SYS_REFCURSOR
		    )
		    IS
		    BEGIN
		    	-- Simple delay using DBMS_SESSION instead of DBMS_LOCK
		    	DBMS_SESSION.SLEEP(1);
		    	out1 := 'foo-' || TO_CHAR(in1) || '-' || in2;
		    	inout1 := in1 + 100;

		    	-- Open cursor for first result set
		    	OPEN cursor1 FOR SELECT 'foo' as col FROM dual UNION ALL SELECT 'bar' FROM dual;

		    	-- Open cursor for second result set
		    	OPEN cursor2 FOR SELECT 'second' as myColumn FROM dual;
		    END testProcedure;
		    """,
		    context
		);

		// Stored procedure with ONLY a ref cursor (no other params)
		dataSource.execute(
		    """
		    CREATE OR REPLACE PROCEDURE testProcedureCursorOnly (
		    	cursor1 OUT SYS_REFCURSOR
		    )
		    IS
		    BEGIN
		    	OPEN cursor1 FOR SELECT 'cursorOnly' as col FROM dual;
		    END testProcedureCursorOnly;
		    """,
		    context
		);

		// Stored procedure with ref cursor FIRST, then in/out params AFTER it
		dataSource.execute(
		    """
		    CREATE OR REPLACE PROCEDURE testProcedureCursorWithInAfter (
		    	cursor1 OUT SYS_REFCURSOR,
		    	in1 IN NUMBER,
		    	inout1 IN OUT NUMBER,
		    	out1 OUT NVARCHAR2
		    )
		    IS
		    BEGIN
		    	inout1 := in1 + inout1;
		    	out1 := 'out-' || TO_CHAR(in1);
		    	OPEN cursor1 FOR SELECT in1 as numVal, inout1 as sumVal FROM dual;
		    END testProcedureCursorWithInAfter;
		    """,
		    context
		);

		// Stored procedure with cursor in the MIDDLE of in/out params
		dataSource.execute(
		    """
		    CREATE OR REPLACE PROCEDURE testProcedureCursorInMiddle (
		    	in1 IN NUMBER,
		    	inout1 IN OUT NUMBER,
		    	cursor1 OUT SYS_REFCURSOR,
		    	in2 IN NVARCHAR2,
		    	out1 OUT NVARCHAR2
		    )
		    IS
		    BEGIN
		    	inout1 := in1 + inout1;
		    	out1 := 'result-' || in2;
		    	OPEN cursor1 FOR SELECT in1 as numVal, in2 as strVal, inout1 as sumVal FROM dual;
		    END testProcedureCursorInMiddle;
		    """,
		    context
		);
	}

	@DisplayName( "It sets generatedKey in query meta" )
	@Test
	public void testGeneratedKey() {
		instance.executeStatement(
		    String.format(
		        """
		                               queryExecute( "
		                               	INSERT INTO generatedKeyTest (name) VALUES ('Michael')
		        ",
		                               	{},
		                               	{ "result": "variables.result", "datasource" : "%s" }
		                               );
		         // println(result)
		                                              """,
		        getDatasourceName() ),
		    context );

		assertThat( variables.get( result ) ).isInstanceOf( IStruct.class );
		IStruct meta = variables.getAsStruct( result );

		// RowID is returned as String
		assertThat( meta.get( Key.rowID ) ).isInstanceOf( String.class );
		assertThat( meta.get( Key.rowID ).toString().length() ).isGreaterThan( 0 );

		Array generatedKeys = meta.getAsArray( Key.rowIDs );

		assertThat( generatedKeys ).hasSize( 1 );
		// Each key is a String
		assertThat( ( ( Array ) generatedKeys.get( 0 ) ).get( 0 ) ).isInstanceOf( String.class );
		// Single INSERT statement with 1 row generates 1 key
		String[] allKeys = ( ( Array ) generatedKeys.get( 0 ) ).stream().map( String::valueOf ).toArray( String[]::new );
		assertThat( allKeys[ 0 ].length() ).isGreaterThan( 0 );

		assertThat( meta.get( "updateCount" ) ).isEqualTo( 1 );
		Array updateCounts = meta.getAsArray( Key.of( "updateCounts" ) );
		assertThat( updateCounts.toArray() ).isEqualTo( new Integer[] { 1 } );
	}

	@DisplayName( "It selects a rowID and uses as String" )
	@Test
	public void testGeneratedKeyAsString() {
		instance.executeStatement(
		    String.format(
		        """
		              result = queryExecute( "SELECT ROWID FROM developers",
		              {},
		              { "datasource" : "%s" }
		              );

		              value = "rowID: " & result.rowID;
		        colMeta = result.$bx.getColumnsMeta()
		                                                         """,
		        getDatasourceName() ),
		    context );
		assertThat( variables.getAsQuery( result ).getColumns().values().toArray( new QueryColumn[ 0 ] )[ 0 ].getType() ).isEqualTo( QueryColumnType.VARCHAR );

		assertThat( variables.get( "value" ) ).isInstanceOf( String.class );
		String rowIDString = variables.getAsString( Key.of( "value" ) );
		assertThat( rowIDString ).startsWith( "rowID: " );

		IStruct rowIDMeta = variables.getAsStruct( Key.of( "colMeta" ) ).getAsStruct( Key.of( "ROWID" ) );
		assertThat( rowIDMeta.getAsInteger( Key.sqltype ) ).isEqualTo( Types.ROWID );
		assertThat( rowIDMeta.get( Key.type ) ).isEqualTo( QueryColumnType.VARCHAR.toString() );

	}

	@DisplayName( "It can select from char 15 field" )
	@Test
	public void testSelectFromCharFields() {
		instance.executeStatement(
		    """
		    queryExecute( "
		    	BEGIN
		    		EXECUTE IMMEDIATE 'CREATE TABLE char15Test ( char15field CHAR(15) )';
		    	EXCEPTION
		    		WHEN OTHERS THEN
		    			IF SQLCODE != -955 THEN
		    				RAISE;
		    			END IF;
		    	END;
		    ",{},{ "datasource" : "OracleDatasource" }
		    );

		    queryExecute( "TRUNCATE TABLE char15Test",{},{ "datasource" : "OracleDatasource" } );
		    queryExecute( "INSERT INTO char15Test ( char15field ) VALUES ( 'value' )",{},{ "datasource" : "OracleDatasource" } );

		    result = queryExecute( "
		    	SELECT * FROM char15Test where char15field = ?
		    	",[ {
		    		sqltype : "varchar",
		    		value: "value"
		    	}],{ "datasource" : "OracleDatasource" }
		    );
		    println( result )
		    """,
		    context );
		// Verify that the query found the row without needing RTRIM
		assertThat( variables.getAsQuery( result ).size() ).isEqualTo( 1 );

	}

	@DisplayName( "It can call stored proc" )
	@Test
	public void testCallStoredProc() {
		instance.executeSource(
		    """
		    <bx:storedproc procedure="testProcedure" datasource="OracleDatasource" result="variables.result" debug=true>
		        <bx:procparam dbvarname="in1" value="123" type="in" sqltype="integer" />
		        <bx:procparam dbvarname="in2" value="hello" type="in" sqltype="nvarchar" />
		        <bx:procparam dbvarname="inout1" value="10" type="inout" sqltype="integer" variable="inout1" />
		        <bx:procparam dbvarname="out1" type="out" sqltype="nvarchar" variable="out1" />
		          <bx:procresult name="resultSet1" resultSet=1 />
		          <bx:procresult name="resultSet2" resultSet=2 />
		      </bx:storedproc>
		      """,
		    context, BoxSourceType.BOXTEMPLATE );
		assertThat( variables.get( "inout1" ) ).isEqualTo( 223 );
		assertThat( variables.get( "out1" ) ).isEqualTo( "foo-123-hello" );

		assertThat( variables.get( "resultSet1" ) ).isInstanceOf( Query.class );
		Query rs1 = variables.getAsQuery( Key.of( "resultSet1" ) );
		assertThat( rs1.size() ).isEqualTo( 2 );
		assertThat( rs1.getRowAsStruct( 0 ).getAsString( Key.of( "col" ) ) ).isEqualTo( "foo" );
		assertThat( rs1.getRowAsStruct( 1 ).getAsString( Key.of( "col" ) ) ).isEqualTo( "bar" );

		assertThat( variables.get( "resultSet2" ) ).isInstanceOf( Query.class );
		Query rs2 = variables.getAsQuery( Key.of( "resultSet2" ) );
		assertThat( rs2.size() ).isEqualTo( 1 );
		assertThat( rs2.getRowAsStruct( 0 ).getAsString( Key.of( "myColumn" ) ) ).isEqualTo( "second" );

		assertThat( variables.get( result ) ).isInstanceOf( IStruct.class );
		IStruct resultStruct = variables.getAsStruct( result );

		assertThat( resultStruct.getAsNumber( Key.of( "executionTime" ) ).doubleValue() ).isGreaterThan( 0.0 );
	}

	@DisplayName( "It can handle large blob and clob columns" )
	@Test
	public void testLargeBlobAndClobColumns() {
		instance.executeStatement(
		    """
		    queryExecute( "
		    	BEGIN
		    		EXECUTE IMMEDIATE 'CREATE TABLE large_lob ( id INTEGER PRIMARY KEY, blob_data BLOB, clob_data CLOB )';
		    	EXCEPTION
		    		WHEN OTHERS THEN
		    			IF SQLCODE != -955 THEN
		    				RAISE;
		    			END IF;
		    	END;
		    ",{},{ "datasource" : "OracleDatasource" }
		    );

		    queryExecute( "TRUNCATE TABLE large_lob", {}, { "datasource" : "OracleDatasource" } );
		    """, context );
		// @formatter:off
		instance.executeStatement(
		    """
				newLobData = "";
				// ~300 chars
				quote = "
		               	Farewell, Aragorn! Go to Minas Tirith and save my people! I
		               	have failed.
		               	No! said Aragorn, taking his hand and kissing his brow. You
		               	have conquered. Few have gained such a victory. Be at peace! Minas
		               	Tirith shall not fall!
		        ";
				// times 1000 = ~300,000 chars
				for( i=1; i <= 1000; i = i + 1 ) {
					newLobData = newLobData & quote;
				}
		        insert = queryExecute( "INSERT INTO large_lob ( id, blob_data, clob_data ) VALUES ( 1, :blobData, :clobData )", { 
		        	blobData: { value: newLobData, sqltype: "blob" },
		        	clobData: { value: newLobData, sqltype: "clob" }
		        }, { "datasource" : "OracleDatasource" } );
		    """, context );
		instance.executeStatement(
		    """
		        result = queryExecute( "SELECT * FROM large_lob WHERE id = 1", {}, { "datasource" : "OracleDatasource" } );
		    """, context );
		// @formatter:on
		assertThat( variables.get( result ) ).isInstanceOf( Query.class );
		Query query = variables.getAsQuery( result );
		assertEquals( 1, query.size() );
		IStruct	firstRow	= query.getRowAsStruct( 0 );

		// Test BLOB data
		Object	blobData	= firstRow.get( Key.of( "BLOB_DATA" ) );
		assertThat( blobData ).isNotNull();
		// BLOB data may be returned as byte[] or other types depending on driver
		if ( blobData instanceof byte[] ) {
			String retrieved = new String( ( byte[] ) blobData, java.nio.charset.StandardCharsets.UTF_8 );
			assertThat( retrieved.length() ).isAtLeast( 300000 );
		}

		// Test CLOB data
		Object clobData = firstRow.get( Key.of( "CLOB_DATA" ) );
		assertThat( clobData ).isNotNull();
		assertThat( clobData ).isInstanceOf( String.class );
		String clobString = ( String ) clobData;
		assertThat( clobString.length() ).isAtLeast( 300000 );
		// Use containsMatch to handle whitespace variations
		assertThat( clobString ).containsMatch( "Farewell,\\s+Aragorn!" );
		assertThat( clobString ).containsMatch( "Minas\\s+Tirith\\s+shall\\s+not\\s+fall!" );
	}

	@DisplayName( "proc out vars transform custom JDBC driver types" )
	@Test
	public void testProcOutVarTransformCustomJDBCDriverTypes() {
		// Create the stored procedure
		instance.executeStatement(
		    """
		    queryExecute( "
		    	CREATE OR REPLACE PROCEDURE getRowIdProc (
		    		outRowId OUT ROWID
		    	)
		    	IS
		    	BEGIN
		    		SELECT ROWID INTO outRowId FROM dual;
		    	END getRowIdProc;
		    ",{},{ "datasource" : "OracleDatasource" }
		    );
		    """, context );

		instance.executeSource(
		    """
		    <bx:storedproc procedure="getRowIdProc" datasource="OracleDatasource" result="variables.result" debug=true>
		        <bx:procparam dbvarname="outRowId" type="out" sqltype="string" variable="returnedRowId" />
		    </bx:storedproc>
		      """,
		    context, BoxSourceType.BOXTEMPLATE );

		// Verify that we got a ROWID back
		assertThat( variables.get( "returnedRowId" ) ).isNotNull();
		assertThat( variables.get( "returnedRowId" ) ).isInstanceOf( String.class );
		String rowIdString = variables.getAsString( Key.of( "returnedRowId" ) );
		assertThat( rowIdString.length() ).isGreaterThan( 0 );
	}

	@DisplayName( "proc out vars transform custom JDBC driver types named" )
	@Test
	public void testProcOutVarTransformCustomJDBCDriverTypesNamed() {
		// Create the stored procedure
		instance.executeStatement(
		    """
		    queryExecute( "
		    	CREATE OR REPLACE PROCEDURE getRowIdProc (
		    		outRowId OUT ROWID
		    	)
		    	IS
		    	BEGIN
		    		SELECT ROWID INTO outRowId FROM dual;
		    	END getRowIdProc;
		    ",{},{ "datasource" : "OracleDatasource" }
		    );
		    """, context );

		instance.executeSource(
		    """
		    <bx:storedproc procedure="getRowIdProc" datasource="OracleDatasource" result="variables.result" debug=true>
		        <bx:procparam dbvarname="outRowId" type="out" sqltype="string" variable="returnedRowId" />
		    </bx:storedproc>
		    """,
		    context, BoxSourceType.BOXTEMPLATE );

		// Verify that we got a ROWID back
		assertThat( variables.get( "returnedRowId" ) ).isNotNull();
		assertThat( variables.get( "returnedRowId" ) ).isInstanceOf( String.class );
		String rowIdString = variables.getAsString( Key.of( "returnedRowId" ) );
		assertThat( rowIdString.length() ).isGreaterThan( 0 );
	}

	@DisplayName( "It can call stored proc with ref cursor only (named)" )
	@Test
	public void testCallStoredProcCursorOnlyNamed() {
		instance.executeSource(
		    """
		    <bx:storedproc procedure="testProcedureCursorOnly" datasource="OracleDatasource" result="variables.result" debug=true>
		        <bx:procresult name="resultSet1" resultSet=1 />
		    </bx:storedproc>
		    """,
		    context, BoxSourceType.BOXTEMPLATE );

		assertThat( variables.get( "resultSet1" ) ).isInstanceOf( Query.class );
		Query rs1 = variables.getAsQuery( Key.of( "resultSet1" ) );
		assertThat( rs1.size() ).isEqualTo( 1 );
		assertThat( rs1.getRowAsStruct( 0 ).getAsString( Key.of( "col" ) ) ).isEqualTo( "cursorOnly" );
	}

	@DisplayName( "It can call stored proc with in/out params after OUT cursor (named)" )
	@Test
	public void testCallStoredProcCursorWithInAfterNamed() {
		instance.executeSource(
		    """
		    <bx:storedproc procedure="testProcedureCursorWithInAfter" datasource="OracleDatasource" result="variables.result" debug=true>
		      <bx:procparam dbvarname="out1" type="out" sqltype="nvarchar" variable="out1" />
		      <bx:procparam dbvarname="in1" value="42" type="in" sqltype="integer" />
		      <bx:procresult name="resultSet1" resultSet=1 />
		      <bx:procparam dbvarname="inout1" value="8" type="inout" sqltype="integer" variable="inout1" />
		    </bx:storedproc>
		    """,
		    context, BoxSourceType.BOXTEMPLATE );

		assertThat( variables.get( "inout1" ) ).isEqualTo( 50 );
		assertThat( variables.get( "out1" ) ).isEqualTo( "out-42" );

		assertThat( variables.get( "resultSet1" ) ).isInstanceOf( Query.class );
		Query rs1 = variables.getAsQuery( Key.of( "resultSet1" ) );
		assertThat( rs1.size() ).isEqualTo( 1 );
		assertThat( rs1.getRowAsStruct( 0 ).getAsNumber( Key.of( "numVal" ) ).doubleValue() ).isEqualTo( 42D );
		assertThat( rs1.getRowAsStruct( 0 ).getAsNumber( Key.of( "sumVal" ) ).doubleValue() ).isEqualTo( 50D );
	}

	@DisplayName( "It can call stored proc with cursor in middle of in/out params (named)" )
	@Test
	public void testCallStoredProcCursorInMiddleNamed() {
		instance.executeSource(
		    """
		    <bx:storedproc procedure="testProcedureCursorInMiddle" datasource="OracleDatasource" result="variables.result" debug=true>
		      <bx:procparam dbvarname="in2" value="world" type="in" sqltype="nvarchar" />
		      <bx:procparam dbvarname="out1" type="out" sqltype="nvarchar" variable="out1" />
		      <bx:procparam dbvarname="in1" value="10" type="in" sqltype="integer" />
		      <bx:procparam dbvarname="inout1" value="5" type="inout" sqltype="integer" variable="inout1" />
		      <bx:procresult name="resultSet1" resultSet=1 />
		    </bx:storedproc>
		    """,
		    context, BoxSourceType.BOXTEMPLATE );

		assertThat( variables.get( "inout1" ) ).isEqualTo( 15 );
		assertThat( variables.get( "out1" ) ).isEqualTo( "result-world" );

		assertThat( variables.get( "resultSet1" ) ).isInstanceOf( Query.class );
		Query rs1 = variables.getAsQuery( Key.of( "resultSet1" ) );
		assertThat( rs1.size() ).isEqualTo( 1 );
		assertThat( rs1.getRowAsStruct( 0 ).getAsNumber( Key.of( "numVal" ) ).doubleValue() ).isEqualTo( 10D );
		assertThat( rs1.getRowAsStruct( 0 ).getAsString( Key.of( "strVal" ) ) ).isEqualTo( "world" );
		assertThat( rs1.getRowAsStruct( 0 ).getAsNumber( Key.of( "sumVal" ) ).doubleValue() ).isEqualTo( 15D );
	}

	@DisplayName( "It can call stored proc with ref cursor only (positional)" )
	@Test
	public void testCallStoredProcCursorOnlyPositional() {
		instance.executeSource(
		    """
		    <bx:storedproc procedure="testProcedureCursorOnly" datasource="OracleDatasource" result="variables.result" debug=true>
		        <bx:procresult name="resultSet1" resultSet=1 />
		    </bx:storedproc>
		    """,
		    context, BoxSourceType.BOXTEMPLATE );

		assertThat( variables.get( "resultSet1" ) ).isInstanceOf( Query.class );
		Query rs1 = variables.getAsQuery( Key.of( "resultSet1" ) );
		assertThat( rs1.size() ).isEqualTo( 1 );
		assertThat( rs1.getRowAsStruct( 0 ).getAsString( Key.of( "col" ) ) ).isEqualTo( "cursorOnly" );
	}

	@DisplayName( "It can call stored proc with in/out params after OUT cursor (positional)" )
	@Test
	public void testCallStoredProcCursorWithInAfterPositional() {
		// Proc signature: cursor1 OUT, in1 IN, inout1 INOUT, out1 OUT
		instance.executeSource(
		    """
		    <bx:storedproc procedure="testProcedureCursorWithInAfter" datasource="OracleDatasource" result="variables.result" debug=true>
		        <bx:procresult name="resultSet1" resultSet=1 />
		        <bx:procparam value="42" type="in" sqltype="integer" />
		        <bx:procparam value="8" type="inout" sqltype="integer" variable="inout1" />
		        <bx:procparam type="out" sqltype="nvarchar" variable="out1" />
		    </bx:storedproc>
		    """,
		    context, BoxSourceType.BOXTEMPLATE );

		assertThat( variables.get( "inout1" ) ).isEqualTo( 50 );
		assertThat( variables.get( "out1" ) ).isEqualTo( "out-42" );

		assertThat( variables.get( "resultSet1" ) ).isInstanceOf( Query.class );
		Query rs1 = variables.getAsQuery( Key.of( "resultSet1" ) );
		assertThat( rs1.size() ).isEqualTo( 1 );
		assertThat( rs1.getRowAsStruct( 0 ).getAsNumber( Key.of( "numVal" ) ).doubleValue() ).isEqualTo( 42D );
		assertThat( rs1.getRowAsStruct( 0 ).getAsNumber( Key.of( "sumVal" ) ).doubleValue() ).isEqualTo( 50D );
	}

	@DisplayName( "It can call stored proc with cursor in middle of in/out params (positional)" )
	@Test
	public void testCallStoredProcCursorInMiddlePositional() {
		// Proc signature: in1 IN, inout1 INOUT, cursor1 OUT, in2 IN, out1 OUT
		instance.executeSource(
		    """
		    <bx:storedproc procedure="testProcedureCursorInMiddle" datasource="OracleDatasource" result="variables.result" debug=true>
		        <bx:procparam value="10" type="in" sqltype="integer" />
		        <bx:procparam value="5" type="inout" sqltype="integer" variable="inout1" />
		        <bx:procresult name="resultSet1" resultSet=1 />
		        <bx:procparam value="world" type="in" sqltype="nvarchar" />
		        <bx:procparam type="out" sqltype="nvarchar" variable="out1" />
		    </bx:storedproc>
		    """,
		    context, BoxSourceType.BOXTEMPLATE );

		assertThat( variables.get( "inout1" ) ).isEqualTo( 15 );
		assertThat( variables.get( "out1" ) ).isEqualTo( "result-world" );

		assertThat( variables.get( "resultSet1" ) ).isInstanceOf( Query.class );
		Query rs1 = variables.getAsQuery( Key.of( "resultSet1" ) );
		assertThat( rs1.size() ).isEqualTo( 1 );
		assertThat( rs1.getRowAsStruct( 0 ).getAsNumber( Key.of( "numVal" ) ).doubleValue() ).isEqualTo( 10D );
		assertThat( rs1.getRowAsStruct( 0 ).getAsString( Key.of( "strVal" ) ) ).isEqualTo( "world" );
		assertThat( rs1.getRowAsStruct( 0 ).getAsNumber( Key.of( "sumVal" ) ).doubleValue() ).isEqualTo( 15D );
	}

	@DisplayName( "It can handle float query param with leading space" )
	@Test
	public void testFloatQueryParamWithLeadingSpace() {
		instance.executeStatement(
		    """
		    result = queryExecute(
		        "SELECT :floatVal as floatValue FROM dual",
		        {
		            floatVal: { value: " 0220692.03", sqltype: "float" }
		        },
		        { "datasource" : "OracleDatasource" }
		    );
		    """,
		    context );

		assertThat( variables.get( result ) ).isInstanceOf( Query.class );
		Query query = variables.getAsQuery( result );
		assertThat( query.size() ).isEqualTo( 1 );
		assertThat( query.getRowAsStruct( 0 ).getAsNumber( Key.of( "floatValue" ) ).doubleValue() ).isEqualTo( 220692.03D );
	}
}
