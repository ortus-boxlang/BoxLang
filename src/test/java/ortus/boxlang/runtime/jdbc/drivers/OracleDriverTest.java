package ortus.boxlang.runtime.jdbc.drivers;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.sql.SQLException;
import java.sql.Types;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIf;

import ortus.boxlang.compiler.parser.BoxSourceType;
import ortus.boxlang.runtime.BoxRuntime;
import ortus.boxlang.runtime.context.IBoxContext;
import ortus.boxlang.runtime.context.ScriptingRequestBoxContext;
import ortus.boxlang.runtime.jdbc.DataSource;
import ortus.boxlang.runtime.jdbc.ExecutedQuery;
import ortus.boxlang.runtime.scopes.Key;
import ortus.boxlang.runtime.types.Array;
import ortus.boxlang.runtime.types.IStruct;
import ortus.boxlang.runtime.types.Query;
import ortus.boxlang.runtime.types.QueryColumn;
import ortus.boxlang.runtime.types.QueryColumnType;
import ortus.boxlang.runtime.types.Struct;
import ortus.boxlang.runtime.types.exceptions.DatabaseException;

@EnabledIf( "tools.JDBCTestUtils#hasOracleModule" )
public class OracleDriverTest extends AbstractDriverTest {

	public static DataSource	oracleDatasource;

	protected static Key		datasourceName		= Key.of( "OracleDatasource" );

	protected static IStruct	datasourceConfig	= Struct.of(
	    "username", "system",
	    "password", "123456Password",
	    "host", "localhost",
	    "port", "1521",
	    "driver", "oracle",
	    "serviceName", "XEPDB1"
	);

	@BeforeAll
	public static void setUp() {
		instance = BoxRuntime.getInstance( true );
		IBoxContext setUpContext = new ScriptingRequestBoxContext( instance.getRuntimeContext() );
		oracleDatasource = AbstractDriverTest.setupTestDatasource( instance, setUpContext, datasourceName, datasourceConfig );
		OracleDriverTest.createGeneratedKeyTable( oracleDatasource, setUpContext );
		OracleDriverTest.createStoredProcedure( oracleDatasource, setUpContext );
	}

	@AfterAll
	public static void teardown() throws SQLException {
		IBoxContext tearDownContext = new ScriptingRequestBoxContext( instance.getRuntimeContext() );
		AbstractDriverTest.teardownTestDatasource( tearDownContext, oracleDatasource );
	}

	/**
	 * Override to provide driver-specific datasource name
	 */
	@Override
	String getDatasourceName() {
		return "OracleDatasource";
	}

	public static void createGeneratedKeyTable( DataSource dataSource, IBoxContext context ) {
		try {
			dataSource.execute( "CREATE TABLE generatedKeyTest( id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR2(155))", context );
		} catch ( DatabaseException ignored ) {
		}
	}

	public static void createStoredProcedure( DataSource dataSource, IBoxContext context ) {
		dataSource.execute(
		    """
		    CREATE OR REPLACE PROCEDURE testProcedure (
		    	in1 IN NUMBER DEFAULT 45,
		    	in2 IN NVARCHAR2,
		    	inout1 IN OUT NUMBER,
		    	out1 OUT NVARCHAR2,
		    	cursor1 OUT SYS_REFCURSOR,
		    	cursor2 OUT SYS_REFCURSOR
		    )
		    IS
		    BEGIN
		    	-- Simple delay using DBMS_SESSION instead of DBMS_LOCK
		    	DBMS_SESSION.SLEEP(1);
		    	out1 := 'foo-' || TO_CHAR(in1) || '-' || in2;
		    	inout1 := in1 + 100;

		    	-- Open cursor for first result set
		    	OPEN cursor1 FOR SELECT 'foo' as col FROM dual UNION ALL SELECT 'bar' FROM dual;

		    	-- Open cursor for second result set
		    	OPEN cursor2 FOR SELECT 'second' as myColumn FROM dual;
		    END testProcedure;
		    """,
		    context
		);
	}

	@DisplayName( "It sets generatedKey in query meta" )
	@Test
	public void testGeneratedKey() {
		instance.executeStatement(
		    String.format(
		        """
		                               queryExecute( "
		                               	INSERT INTO generatedKeyTest (name) VALUES ('Michael')
		        ",
		                               	{},
		                               	{ "result": "variables.result", "datasource" : "%s" }
		                               );
		         // println(result)
		                                              """,
		        getDatasourceName() ),
		    context );

		assertThat( variables.get( result ) ).isInstanceOf( IStruct.class );
		IStruct meta = variables.getAsStruct( result );

		// RowID is returned as String
		assertThat( meta.get( Key.rowID ) ).isInstanceOf( String.class );
		assertThat( meta.get( Key.rowID ).toString().length() ).isGreaterThan( 0 );

		Array generatedKeys = meta.getAsArray( Key.rowIDs );

		assertThat( generatedKeys ).hasSize( 1 );
		// Each key is a String
		assertThat( ( ( Array ) generatedKeys.get( 0 ) ).get( 0 ) ).isInstanceOf( String.class );
		// Single INSERT statement with 1 row generates 1 key
		String[] allKeys = ( ( Array ) generatedKeys.get( 0 ) ).stream().map( String::valueOf ).toArray( String[]::new );
		assertThat( allKeys[ 0 ].length() ).isGreaterThan( 0 );

		assertThat( meta.get( "updateCount" ) ).isEqualTo( 1 );
		Array updateCounts = meta.getAsArray( Key.of( "updateCounts" ) );
		assertThat( updateCounts.toArray() ).isEqualTo( new Integer[] { 1 } );
	}

	@DisplayName( "It selects a rowID and uses as String" )
	@Test
	public void testGeneratedKeyAsString() {
		instance.executeStatement(
		    String.format(
		        """
		              result = queryExecute( "SELECT ROWID FROM developers",
		              {},
		              { "datasource" : "%s" }
		              );

		              value = "rowID: " & result.rowID;
		        colMeta = result.$bx.getColumnsMeta()
		                                                         """,
		        getDatasourceName() ),
		    context );
		assertThat( variables.getAsQuery( result ).getColumns().values().toArray( new QueryColumn[ 0 ] )[ 0 ].getType() ).isEqualTo( QueryColumnType.VARCHAR );

		assertThat( variables.get( "value" ) ).isInstanceOf( String.class );
		String rowIDString = variables.getAsString( Key.of( "value" ) );
		assertThat( rowIDString ).startsWith( "rowID: " );

		IStruct rowIDMeta = variables.getAsStruct( Key.of( "colMeta" ) ).getAsStruct( Key.of( "ROWID" ) );
		assertThat( rowIDMeta.getAsInteger( Key.sqltype ) ).isEqualTo( Types.ROWID );
		assertThat( rowIDMeta.get( Key.type ) ).isEqualTo( QueryColumnType.VARCHAR.toString() );

	}

	@DisplayName( "It can select from char 15 field" )
	@Test
	public void testSelectFromCharFields() {
		instance.executeStatement(
		    """
		    queryExecute( "
		    	BEGIN
		    		EXECUTE IMMEDIATE 'CREATE TABLE char15Test ( char15field CHAR(15) )';
		    	EXCEPTION
		    		WHEN OTHERS THEN
		    			IF SQLCODE != -955 THEN
		    				RAISE;
		    			END IF;
		    	END;
		    ",{},{ "datasource" : "OracleDatasource" }
		    );

		    queryExecute( "TRUNCATE TABLE char15Test",{},{ "datasource" : "OracleDatasource" } );
		    queryExecute( "INSERT INTO char15Test ( char15field ) VALUES ( 'value' )",{},{ "datasource" : "OracleDatasource" } );

		    result = queryExecute( "
		    	SELECT * FROM char15Test where char15field = ?
		    	",[ {
		    		sqltype : "varchar",
		    		value: "value"
		    	}],{ "datasource" : "OracleDatasource" }
		    );
		    println( result )
		    """,
		    context );

	}

	@DisplayName( "It can call stored proc" )
	@Test
	@Disabled( "Lacking stored procedure implementation" )
	public void testCallStoredProc() {
		ExecutedQuery.debug = true;
		instance.executeSource(
		    """
		    <bx:storedproc procedure="testProcedure" datasource="OracleDatasource" result="variables.result" debug=true>
		        <bx:procparam name="in1" value="123" type="in" sqltype="integer" />
		        <bx:procparam name="in2" value="hello" type="in" sqltype="nvarchar" />
		        <bx:procparam name="inout1" value="10" type="inout" sqltype="integer" variable="inout1" />
		        <bx:procparam name="out1" type="out" sqltype="nvarchar" variable="out1" />
		        <bx:procresult name="resultSet1" resultSet=1 />
		        <bx:procresult name="resultSet2" resultSet=2 />
		    </bx:storedproc>
		    """,
		    context, BoxSourceType.BOXTEMPLATE );
		ExecutedQuery.debug = false;
		assertThat( variables.get( "inout1" ) ).isEqualTo( 223 );
		assertThat( variables.get( "out1" ) ).isEqualTo( "foo-123-hello" );

		assertThat( variables.get( "resultSet1" ) ).isInstanceOf( Query.class );
		Query rs1 = variables.getAsQuery( Key.of( "resultSet1" ) );
		assertThat( rs1.size() ).isEqualTo( 2 );
		assertThat( rs1.getRowAsStruct( 0 ).getAsString( Key.of( "col" ) ) ).isEqualTo( "foo" );
		assertThat( rs1.getRowAsStruct( 1 ).getAsString( Key.of( "col" ) ) ).isEqualTo( "bar" );

		assertThat( variables.get( "resultSet2" ) ).isInstanceOf( Query.class );
		Query rs2 = variables.getAsQuery( Key.of( "resultSet2" ) );
		assertThat( rs2.size() ).isEqualTo( 1 );
		assertThat( rs2.getRowAsStruct( 0 ).getAsString( Key.of( "myColumn" ) ) ).isEqualTo( "second" );

		assertThat( variables.get( result ) ).isInstanceOf( IStruct.class );
		IStruct resultStruct = variables.getAsStruct( result );

		assertThat( resultStruct.getAsNumber( Key.of( "executionTime" ) ).doubleValue() ).isGreaterThan( 0.0 );
	}

	@DisplayName( "It can handle large blob columns" )
	@Test
	public void testLargeBlobColumns() {
		instance.executeStatement(
		    """
		        result = queryExecute( "CREATE TABLE large_blob ( id INTEGER PRIMARY KEY, data BLOB )" );
		    """, context );
		// @formatter:off
		instance.executeStatement(
		    """
				newBlob = "";
				// ~300 chars
				quote = "
		               	Farewell, Aragorn! Go to Minas Tirith and save my people! I
		               	have failed.
		               	No! said Aragorn, taking his hand and kissing his brow. You
		               	have conquered. Few have gained such a victory. Be at peace! Minas
		               	Tirith shall not fall!
		        ";
				// times 1000 = ~300,000 chars
				for( i=1; i <= 1000; i = i + 1 ) {
					newBlob = newBlob & quote;
				}
		        insert = queryExecute( "INSERT INTO large_blob ( id, data ) VALUES ( 1, :newBlob )", { newBlob: { value: newBlob, sqltype: "blob" } } );
		    """, context );
		instance.executeStatement(
		    """
		        result = queryExecute( "SELECT * FROM large_blob WHERE id = 1" );
		    """, context );
// @formatter:on
		assertThat( variables.get( result ) ).isInstanceOf( Query.class );
		Query query = variables.getAsQuery( result );
		assertEquals( 1, query.size() );
		IStruct	firstRow	= query.getRowAsStruct( 0 );
		Object	data		= firstRow.get( Key.data );
		assertThat( data ).isNotNull();
		// BLOB data may be returned as byte[] or other types depending on driver
		if ( data instanceof byte[] ) {
			String retrieved = new String( ( byte[] ) data, java.nio.charset.StandardCharsets.UTF_8 );
			assertThat( retrieved.length() ).isGreaterThan( 300000 );
		}
	}
}
