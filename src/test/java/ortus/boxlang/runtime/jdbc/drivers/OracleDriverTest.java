package ortus.boxlang.runtime.jdbc.drivers;

import static com.google.common.truth.Truth.assertThat;

import java.sql.SQLException;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIf;

import ortus.boxlang.compiler.parser.BoxSourceType;
import ortus.boxlang.runtime.BoxRuntime;
import ortus.boxlang.runtime.context.IBoxContext;
import ortus.boxlang.runtime.context.ScriptingRequestBoxContext;
import ortus.boxlang.runtime.jdbc.DataSource;
import ortus.boxlang.runtime.jdbc.ExecutedQuery;
import ortus.boxlang.runtime.scopes.Key;
import ortus.boxlang.runtime.types.Array;
import ortus.boxlang.runtime.types.IStruct;
import ortus.boxlang.runtime.types.Query;
import ortus.boxlang.runtime.types.QueryColumn;
import ortus.boxlang.runtime.types.QueryColumnType;
import ortus.boxlang.runtime.types.Struct;
import ortus.boxlang.runtime.types.exceptions.DatabaseException;

@EnabledIf( "tools.JDBCTestUtils#hasOracleModule" )
public class OracleDriverTest extends AbstractDriverTest {

	public static DataSource	oracleDatasource;

	protected static Key		datasourceName		= Key.of( "OracleDatasource" );

	protected static IStruct	datasourceConfig	= Struct.of(
	    "username", "system",
	    "password", "123456Password",
	    "host", "localhost",
	    "port", "1521",
	    "driver", "oracle",
	    "serviceName", "XEPDB1"
	);

	@BeforeAll
	public static void setUp() {
		instance = BoxRuntime.getInstance( true );
		IBoxContext setUpContext = new ScriptingRequestBoxContext( instance.getRuntimeContext() );
		oracleDatasource = AbstractDriverTest.setupTestDatasource( instance, setUpContext, datasourceName, datasourceConfig );
		OracleDriverTest.createGeneratedKeyTable( oracleDatasource, setUpContext );
		OracleDriverTest.createStoredProcedure( oracleDatasource, setUpContext );
	}

	@AfterAll
	public static void teardown() throws SQLException {
		IBoxContext tearDownContext = new ScriptingRequestBoxContext( instance.getRuntimeContext() );
		AbstractDriverTest.teardownTestDatasource( tearDownContext, oracleDatasource );
	}

	/**
	 * Override to provide driver-specific datasource name
	 */
	@Override
	String getDatasourceName() {
		return "OracleDatasource";
	}

	public static void createGeneratedKeyTable( DataSource dataSource, IBoxContext context ) {
		try {
			dataSource.execute( "CREATE TABLE generatedKeyTest( id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR2(155))", context );
		} catch ( DatabaseException ignored ) {
		}
	}

	public static void createStoredProcedure( DataSource dataSource, IBoxContext context ) {
		dataSource.execute(
		    """
		    CREATE OR REPLACE PROCEDURE testProcedure (
		    	in1 IN NUMBER DEFAULT 45,
		    	in2 IN NVARCHAR2,
		    	inout1 IN OUT NUMBER,
		    	out1 OUT NVARCHAR2,
		    	cursor1 OUT SYS_REFCURSOR,
		    	cursor2 OUT SYS_REFCURSOR
		    )
		    IS
		    BEGIN
		    	-- Simple delay using DBMS_SESSION instead of DBMS_LOCK
		    	DBMS_SESSION.SLEEP(1);
		    	out1 := 'foo-' || TO_CHAR(in1) || '-' || in2;
		    	inout1 := in1 + 100;

		    	-- Open cursor for first result set
		    	OPEN cursor1 FOR SELECT 'foo' as col FROM dual UNION ALL SELECT 'bar' FROM dual;

		    	-- Open cursor for second result set
		    	OPEN cursor2 FOR SELECT 'second' as myColumn FROM dual;
		    END testProcedure;
		    """,
		    context
		);
	}

	@DisplayName( "It sets generatedKey in query meta" )
	@Test
	public void testGeneratedKey() {
		instance.executeStatement(
		    String.format(
		        """
		                               queryExecute( "
		                               	INSERT INTO generatedKeyTest (name) VALUES ('Michael')
		        ",
		                               	{},
		                               	{ "result": "variables.result", "datasource" : "%s" }
		                               );
		         // println(result)
		                                              """,
		        getDatasourceName() ),
		    context );

		assertThat( variables.get( result ) ).isInstanceOf( IStruct.class );
		IStruct meta = variables.getAsStruct( result );

		// RowID is returned as String
		assertThat( meta.get( Key.rowID ) ).isInstanceOf( String.class );
		assertThat( meta.get( Key.rowID ).toString().length() ).isGreaterThan( 0 );

		Array generatedKeys = meta.getAsArray( Key.rowIDs );

		assertThat( generatedKeys ).hasSize( 1 );
		// Each key is a String
		assertThat( ( ( Array ) generatedKeys.get( 0 ) ).get( 0 ) ).isInstanceOf( String.class );
		// Single INSERT statement with 1 row generates 1 key
		String[] allKeys = ( ( Array ) generatedKeys.get( 0 ) ).stream().map( String::valueOf ).toArray( String[]::new );
		assertThat( allKeys[ 0 ].length() ).isGreaterThan( 0 );

		assertThat( meta.get( "updateCount" ) ).isEqualTo( 1 );
		Array updateCounts = meta.getAsArray( Key.of( "updateCounts" ) );
		assertThat( updateCounts.toArray() ).isEqualTo( new Integer[] { 1 } );
	}

	@DisplayName( "It selects a rowID and uses as String" )
	@Test
	public void testGeneratedKeyAsString() {
		instance.executeStatement(
		    String.format(
		        """
		        result = queryExecute( "SELECT ROWID FROM developers",
		        {},
		        { "datasource" : "%s" }
		        );

		        value = "rowID: " & result.rowID;
		                                                   """,
		        getDatasourceName() ),
		    context );
		assertThat( variables.getAsQuery( result ).getColumns().values().toArray( new QueryColumn[ 0 ] )[ 0 ].getType() ).isEqualTo( QueryColumnType.VARCHAR );

		assertThat( variables.get( "value" ) ).isInstanceOf( String.class );
		String rowIDString = variables.getAsString( Key.of( "value" ) );
		assertThat( rowIDString ).startsWith( "rowID: " );

	}

	@DisplayName( "It can call stored proc" )
	@Test
	@Disabled( "Lacking stored procedure implementation" )
	public void testCallStoredProc() {
		ExecutedQuery.debug = true;
		instance.executeSource(
		    """
		    <bx:storedproc procedure="testProcedure" datasource="OracleDatasource" result="variables.result" debug=true>
		        <bx:procparam name="in1" value="123" type="in" sqltype="integer" />
		        <bx:procparam name="in2" value="hello" type="in" sqltype="nvarchar" />
		        <bx:procparam name="inout1" value="10" type="inout" sqltype="integer" variable="inout1" />
		        <bx:procparam name="out1" type="out" sqltype="nvarchar" variable="out1" />
		        <bx:procresult name="resultSet1" resultSet=1 />
		        <bx:procresult name="resultSet2" resultSet=2 />
		    </bx:storedproc>
		    """,
		    context, BoxSourceType.BOXTEMPLATE );
		ExecutedQuery.debug = false;
		assertThat( variables.get( "inout1" ) ).isEqualTo( 223 );
		assertThat( variables.get( "out1" ) ).isEqualTo( "foo-123-hello" );

		assertThat( variables.get( "resultSet1" ) ).isInstanceOf( Query.class );
		Query rs1 = variables.getAsQuery( Key.of( "resultSet1" ) );
		assertThat( rs1.size() ).isEqualTo( 2 );
		assertThat( rs1.getRowAsStruct( 0 ).getAsString( Key.of( "col" ) ) ).isEqualTo( "foo" );
		assertThat( rs1.getRowAsStruct( 1 ).getAsString( Key.of( "col" ) ) ).isEqualTo( "bar" );

		assertThat( variables.get( "resultSet2" ) ).isInstanceOf( Query.class );
		Query rs2 = variables.getAsQuery( Key.of( "resultSet2" ) );
		assertThat( rs2.size() ).isEqualTo( 1 );
		assertThat( rs2.getRowAsStruct( 0 ).getAsString( Key.of( "myColumn" ) ) ).isEqualTo( "second" );

		assertThat( variables.get( result ) ).isInstanceOf( IStruct.class );
		IStruct resultStruct = variables.getAsStruct( result );

		assertThat( resultStruct.getAsNumber( Key.of( "executionTime" ) ).doubleValue() ).isGreaterThan( 0.0 );
	}
}