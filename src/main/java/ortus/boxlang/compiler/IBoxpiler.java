
/**
 * The core interface for BoxLang compiler implementations, defining the contract for compiling
 * BoxLang source code into executable Java bytecode.
 *
 * <p>
 * The IBoxpiler interface provides a comprehensive API for:
 * </p>
 * <ul>
 * <li><b>Parsing:</b> Converting BoxLang source code into Abstract Syntax Trees (AST) using ANTLR-based parsers</li>
 * <li><b>Compilation:</b> Transforming AST into Java bytecode for statements, scripts, templates, and classes</li>
 * <li><b>Class Management:</b> Managing class pools for efficient reuse of compiled code</li>
 * <li><b>Java Interop:</b> Generating dynamic interface proxies for seamless Java integration</li>
 * <li><b>Debugging Support:</b> Providing source maps for accurate stack traces and error reporting</li>
 * </ul>
 *
 * <h2>Compilation Modes</h2>
 * <p>
 * The compiler supports multiple compilation modes for different BoxLang constructs:
 * </p>
 * <ul>
 * <li><b>Statements:</b> Individual lines or blocks of code ({@link #compileStatement})</li>
 * <li><b>Scripts:</b> Complete procedural programs ({@link #compileScript})</li>
 * <li><b>Templates:</b> Mixed content files with HTML/text and BoxLang code ({@link #compileTemplate})</li>
 * <li><b>Classes:</b> Full OOP constructs with classes, components, and interfaces ({@link #compileClass})</li>
 * </ul>
 *
 * <h2>Multi-Parser Architecture</h2>
 * <p>
 * BoxLang uses ANTLR v4 with multiple grammar parsers for different syntaxes:
 * </p>
 * <ul>
 * <li><b>BoxParser:</b> Native BoxLang syntax (primary)</li>
 * <li><b>CFParser:</b> CFML/ColdFusion compatibility mode</li>
 * <li><b>SQLParser:</b> SQL query parsing for query manipulation</li>
 * <li><b>DocParser:</b> JavaDoc-style documentation parsing</li>
 * </ul>
 *
 * <h2>Implementation Notes</h2>
 * <p>
 * Concrete implementations of this interface (e.g., ASMBoxpiler, JavaBoxpiler) must:
 * </p>
 * <ul>
 * <li>Integrate with the BoxRuntime environment for logging and configuration</li>
 * <li>Manage class pools and caching for performance optimization</li>
 * <li>Generate bytecode compatible with {@link #BYTECODE_VERSION}</li>
 * <li>Provide source maps for debugging and error reporting</li>
 * <li>Handle interface proxies for Java interoperability</li>
 * </ul>
 *
 * @see ortus.boxlang.compiler.asmboxpiler.ASMBoxpiler
 * @see ortus.boxlang.compiler.javaboxpiler.JavaBoxpiler
 * @see ortus.boxlang.compiler.parser.BoxSourceType
 * @see ortus.boxlang.runtime.runnables.IBoxRunnable
 */
package ortus.boxlang.compiler;

import java.io.File;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ortus.boxlang.compiler.parser.BoxSourceType;
import ortus.boxlang.compiler.parser.ParsingResult;
import ortus.boxlang.runtime.context.IBoxContext;
import ortus.boxlang.runtime.dynamic.javaproxy.InterfaceProxyDefinition;
import ortus.boxlang.runtime.runnables.IBoxRunnable;
import ortus.boxlang.runtime.runnables.IProxyRunnable;
import ortus.boxlang.runtime.scopes.Key;
import ortus.boxlang.runtime.types.exceptions.BoxRuntimeException;
import ortus.boxlang.runtime.util.ResolvedFilePath;

public interface IBoxpiler {

	/**
	 * The bytecode version identifier for compiled BoxLang classes.
	 *
	 * <p>
	 * This version number is embedded in every compiled class file and is used to determine
	 * compatibility when loading pre-compiled classes. The version is incremented whenever
	 * breaking changes are made to:
	 * </p>
	 * <ul>
	 * <li>The bytecode generation format</li>
	 * <li>Runtime APIs that compiled bytecode directly interacts with</li>
	 * <li>Class structure or method signatures in the runtime</li>
	 * </ul>
	 *
	 * <p>
	 * When loading a pre-compiled class, the runtime checks this version to ensure the
	 * bytecode is compatible. Mismatched versions will trigger recompilation from source.
	 * </p>
	 */
	public static final int		BYTECODE_VERSION	= 1;

	/**
	 * Java reserved words that cannot be used as identifiers in generated bytecode.
	 *
	 * <p>
	 * Since BoxLang compiles to JVM bytecode, we must avoid using Java reserved words
	 * as class names, method names, or variable names in the generated code. This set
	 * is used during compilation to escape or transform identifiers that conflict with
	 * Java's syntax.
	 * </p>
	 *
	 * <p>
	 * BoxLang developers can still use these words in their source code, but the compiler
	 * will automatically rename them in the generated bytecode to avoid conflicts.
	 * </p>
	 */
	static final Set<String>	RESERVED_WORDS		= new HashSet<>(
	    Arrays.asList( "abstract", "assert", "boolean", "break", "byte", "case", "catch", "char",
	        "class", "const", "continue", "default", "do", "double", "else", "enum", "extends", "final", "finally", "float", "for", "goto", "if", "implements",
	        "import", "instanceof", "int", "interface", "long", "native", "new", "package", "private", "protected", "public", "return", "short", "static",
	        "strictfp", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "try", "void", "volatile", "while" ) );

	/**
	 * Generates an MD5 hash for a given string. This is used internally for creating
	 * unique identifiers for compiled classes and ensuring cache consistency.
	 *
	 * <p>
	 * This is a utility method that should be moved to a dedicated utility class.
	 * </p>
	 *
	 * @param md5 The string to hash
	 *
	 * @return The MD5 hash as a hexadecimal string
	 *
	 * @throws BoxRuntimeException if the MD5 algorithm is not available
	 */
	static String MD5( String md5 ) {
		try {
			java.security.MessageDigest	md		= java.security.MessageDigest.getInstance( "MD5" );
			byte[]						array	= md.digest( md5.getBytes() );
			StringBuilder				sb		= new StringBuilder();
			for ( byte b : array ) {
				sb.append( Integer.toHexString( ( b & 0xFF ) | 0x100 ).substring( 1, 3 ) );
			}
			return sb.toString();
		} catch ( java.security.NoSuchAlgorithmException e ) {
			throw new BoxRuntimeException( "Error compiling source", e );
		}
	}

	/**
	 * Retrieves the class pool for a given name. Class pools are collections of compiled classes
	 * that can be reused for efficient compilation and execution.
	 *
	 * @param classPoolName The name of the class pool to retrieve
	 *
	 * @return A map of class names to ClassInfo objects representing the compiled classes in the pool
	 */
	Map<String, ClassInfo> getClassPool( String classPoolName );

	/**
	 * Compiles a single BoxLang statement into an executable Java class.
	 * Statements are individual lines or blocks of BoxLang code that don't constitute
	 * a complete script or template.
	 *
	 * @param source The BoxLang statement source code to compile
	 * @param type   The source type (BoxLang or CFML) for parser selection
	 *
	 * @return A compiled class implementing IBoxRunnable that can be executed
	 */
	Class<IBoxRunnable> compileStatement( String source, BoxSourceType type );

	/**
	 * Compiles a BoxLang script into an executable Java class.
	 * Scripts are complete BoxLang programs with procedural code that can be executed directly.
	 *
	 * @param source The BoxLang script source code to compile
	 * @param type   The source type (BoxLang or CFML) for parser selection
	 *
	 * @return A compiled class implementing IBoxRunnable that can be executed
	 */
	Class<IBoxRunnable> compileScript( String source, BoxSourceType type );

	/**
	 * Compiles a BoxLang template file into an executable Java class.
	 * Templates are files containing mixed content (HTML, text, and BoxLang code) typically
	 * used for web page generation.
	 *
	 * @param resolvedFilePath The resolved file path to the template file
	 *
	 * @return A compiled class implementing IBoxRunnable that can be executed
	 */
	Class<IBoxRunnable> compileTemplate( ResolvedFilePath resolvedFilePath );

	/**
	 * Compiles a BoxLang template file into bytecode without loading it as a class.
	 * This method is useful for pre-compilation scenarios where you want to generate
	 * bytecode for storage or transmission without immediate execution.
	 *
	 * @param resolvedFilePath The resolved file path to the template file
	 *
	 * @return A list of byte arrays representing the compiled class and any inner classes
	 */
	List<byte[]> compileTemplateBytes( ResolvedFilePath resolvedFilePath );

	/**
	 * Compiles a BoxLang class definition from source code into an executable Java class.
	 * This handles BoxLang classes, components, and interfaces with full OOP support.
	 *
	 * @param source The BoxLang class source code to compile
	 * @param type   The source type (BoxLang or CFML) for parser selection
	 *
	 * @return A compiled class implementing IBoxRunnable that can be executed
	 */
	Class<IBoxRunnable> compileClass( String source, BoxSourceType type );

	/**
	 * Compiles a BoxLang class definition from a file into an executable Java class.
	 * This handles BoxLang classes, components, and interfaces with full OOP support.
	 *
	 * @param resolvedFilePath The resolved file path to the class file
	 *
	 * @return A compiled class implementing IBoxRunnable that can be executed
	 */
	Class<IBoxRunnable> compileClass( ResolvedFilePath resolvedFilePath );

	/**
	 * Compiles a dynamic Java interface proxy from a BoxLang class or component.
	 * This enables BoxLang objects to implement Java interfaces at runtime, providing
	 * seamless Java interoperability for callbacks, listeners, and other interface-based APIs.
	 *
	 * @param context    The execution context for the compilation
	 * @param definition The interface proxy definition containing the target interfaces and BoxLang implementation
	 *
	 * @return A compiled proxy class implementing IProxyRunnable and the specified Java interfaces
	 */
	Class<IProxyRunnable> compileInterfaceProxy( IBoxContext context, InterfaceProxyDefinition definition );

	/**
	 * Parses a BoxLang source file into an Abstract Syntax Tree (AST) without compilation.
	 * This method performs syntactic analysis only and does not generate bytecode.
	 *
	 * @param file The file to parse
	 *
	 * @return A ParsingResult containing the AST and any parsing errors or warnings
	 */
	ParsingResult parse( File file );

	/**
	 * Parses BoxLang source code into an Abstract Syntax Tree (AST) without compilation.
	 * This method performs syntactic analysis only and does not generate bytecode.
	 *
	 * @param source           The BoxLang source code to parse
	 * @param type             The source type (BoxLang or CFML) for parser selection
	 * @param classOrInterface True if parsing a class/interface definition, false for scripts/templates
	 *
	 * @return A ParsingResult containing the AST and any parsing errors or warnings
	 */
	ParsingResult parse( String source, BoxSourceType type, Boolean classOrInterface );

	/**
	 * Parses a BoxLang source file into an Abstract Syntax Tree (AST), throwing an exception on errors.
	 * Unlike {@link #parse(File)}, this method will throw a BoxRuntimeException if parsing fails.
	 *
	 * @param file The file to parse
	 *
	 * @return A ParsingResult containing the AST (guaranteed to be error-free)
	 *
	 * @throws BoxRuntimeException if parsing fails
	 */
	ParsingResult parseOrFail( File file );

	/**
	 * Parses BoxLang source code into an Abstract Syntax Tree (AST), throwing an exception on errors.
	 * Unlike {@link #parse(String, BoxSourceType, Boolean)}, this method will throw a BoxRuntimeException if parsing fails.
	 *
	 * @param source           The BoxLang source code to parse
	 * @param type             The source type (BoxLang or CFML) for parser selection
	 * @param classOrInterface True if parsing a class/interface definition, false for scripts/templates
	 *
	 * @return A ParsingResult containing the AST (guaranteed to be error-free)
	 *
	 * @throws BoxRuntimeException if parsing fails
	 */
	ParsingResult parseOrFail( String source, BoxSourceType type, Boolean classOrInterface );

	/**
	 * Validates a parsing result and throws an exception if errors are present.
	 * This method is typically called after {@link #parse} to ensure the parse was successful
	 * before proceeding with compilation.
	 *
	 * @param result The parsing result to validate
	 * @param source The original source code (used for error reporting)
	 *
	 * @return The same ParsingResult if validation succeeds
	 *
	 * @throws BoxRuntimeException if the parsing result contains errors
	 */
	ParsingResult validateParse( ParsingResult result, String source );

	/**
	 * Prints the transpiled Java source code for debugging purposes.
	 * This method is useful for inspecting the generated Java code that results from
	 * compiling BoxLang source, particularly for troubleshooting compilation issues.
	 *
	 * @param result    The parsing result containing the AST
	 * @param classInfo The class information containing the transpiled code
	 * @param target    The PrintStream to write the transpiled code to (e.g., System.out)
	 */
	void printTranspiledCode( ParsingResult result, ClassInfo classInfo, PrintStream target );

	/**
	 * Retrieves the source map for a compiled class by its fully qualified name (FQN).
	 * Source maps provide mapping information between the generated Java bytecode and the
	 * original BoxLang source code, enabling accurate stack traces and debugging.
	 *
	 * @param FQN The fully qualified name of the compiled class
	 *
	 * @return The SourceMap containing line number mappings and source information, or null if not found
	 */
	SourceMap getSourceMapFromFQN( String FQN );

	/**
	 * Extracts the base fully qualified name (FQN) from a class that may contain inner class suffixes.
	 *
	 * <p>
	 * BoxLang generates inner classes for functions, closures, lambdas, and component body code.
	 * This method strips these suffixes to retrieve the original class FQN:
	 * </p>
	 * <ul>
	 * <li><code>$Func_xxx</code> - Named functions</li>
	 * <li><code>$Closure_xxx</code> - Closure expressions</li>
	 * <li><code>$Lambda_xxx</code> - Lambda expressions</li>
	 * <li><code>$ComponentBodyLambda_xxx</code> - Component body execution</li>
	 * <li><code>$n</code> - Anonymous inner classes (where n is a digit)</li>
	 * </ul>
	 *
	 * <p>
	 * This is essential for source map lookup and debugging, as source maps are stored
	 * against the base class, not the inner classes.
	 * </p>
	 *
	 * @param FQN The full fully qualified name that may contain inner class suffixes
	 *
	 * @return The base FQN with inner class suffixes removed, or the original FQN if no suffixes found
	 */
	static String getBaseFQN( String FQN ) {
		// If fqn ends with $Func_xxx, $Closure_xxx, or $Lambda_xxx, then we need to strip that off to get the original FQN
		// Check $Func_ first as it's most common
		int funcIndex = FQN.indexOf( "$Func_" );
		if ( funcIndex != -1 ) {
			return FQN.substring( 0, funcIndex );
		}

		int closureIndex = FQN.indexOf( "$Closure_" );
		if ( closureIndex != -1 ) {
			return FQN.substring( 0, closureIndex );
		}

		int lambdaIndex = FQN.indexOf( "$Lambda_" );
		if ( lambdaIndex != -1 ) {
			return FQN.substring( 0, lambdaIndex );
		}

		// $ComponentBodyLambda_
		int componentBodyLambdaIndex = FQN.indexOf( "$ComponentBodyLambda_" );
		if ( componentBodyLambdaIndex != -1 ) {
			return FQN.substring( 0, componentBodyLambdaIndex );
		}

		// Check for anonymous inner classes (e.g., ClassName$1, ClassName$2, etc.)
		// Look for dollar sign followed by only digits at the end of the string
		int lastDollarIndex = FQN.lastIndexOf( '$' );
		if ( lastDollarIndex != -1 && lastDollarIndex < FQN.length() - 1 ) {
			// Check if everything after the last $ is digits
			boolean allDigits = true;
			for ( int i = lastDollarIndex + 1; i < FQN.length(); i++ ) {
				if ( !Character.isDigit( FQN.charAt( i ) ) ) {
					allDigits = false;
					break;
				}
			}
			if ( allDigits ) {
				return FQN.substring( 0, lastDollarIndex );
			}
		}

		return FQN;
	}

	/**
	 * Compiles a class from the class pool into bytecode without loading it.
	 * This method retrieves a previously parsed class from the specified class pool
	 * and generates its bytecode for storage or transmission.
	 *
	 * @param classPoolName The name of the class pool containing the class
	 * @param FQN           The fully qualified name of the class to compile
	 *
	 * @return A list of byte arrays representing the compiled class and any inner classes
	 */
	List<byte[]> compileClassInfo( String classPoolName, String FQN );

	/**
	 * Clears the page pool, removing all cached compiled templates and scripts.
	 * This is typically called during development or when dynamic reloading is needed.
	 * Does not affect the class pool for BoxLang classes and components.
	 */
	void clearPagePool();

	/**
	 * Gets the unique name identifier for this Boxpiler implementation.
	 * This is used by the runtime to distinguish between different compiler implementations
	 * (e.g., ASM-based compiler vs. Java source compiler).
	 *
	 * @return A Key representing the compiler's unique name
	 */
	Key getName();
}
