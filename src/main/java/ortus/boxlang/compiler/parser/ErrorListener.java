package ortus.boxlang.compiler.parser;

import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.Token;
import ortus.boxlang.compiler.ast.Issue;
import ortus.boxlang.compiler.ast.Point;
import ortus.boxlang.compiler.ast.Position;
import ortus.boxlang.compiler.ast.Source;

import java.util.List;

public class ErrorListener extends BaseErrorListener {

	public ErrorListener() {
	}

	private Source		sourceToParse;
	private String[]	sourceLines;
	private List<Issue>	issues;
	private int			windowSize;
	private int			startLine	= 0;
	private int			startColumn	= 0;

	/**
	 * Creates an instance of the error listener and supplies the source code and the list of issues to populate
	 *
	 * @param source the source code in\n separated form
	 * @param issues the list of issues to populate, which may be empty
	 */
	public ErrorListener( Source source, List<Issue> issues, int windowSize ) {
		this.issues			= issues;
		this.sourceToParse	= source;
		this.sourceLines	= source.toString().replaceAll( "\\r", "" ).split( "\n" );
		this.windowSize		= windowSize;
	}

	private int errorCount = 0;

	private void reset() {
		errorCount = 0;
		issues.clear();
	}

	private int getErrorCount() {
		return errorCount;
	}

	private void setStartLine( int startLine ) {
		this.startLine = startLine;
	}

	private void setStartColumn( int startColumn ) {
		this.startColumn = startColumn;
	}

	/**
	 * This method is called by the parser when an error is detected, and we install it in place of the
	 * standard console error listener that Antlr provides. This allows us, in conjunction with a custom
	 * error srategy, to provide more pertient error messages to the user.
	 *
	 * @param recognizer         the parser that detected the error
	 * @param offendingSymbol    the token that caused the error, when it can be identified
	 * @param line               the line number where the error occurred
	 * @param charPositionInLine the character position within the line where the error occurred
	 * @param msg                the message generated by the custom error strategy
	 * @param e                  the exception that caused the error, if there was one
	 */
	@Override
	public void syntaxError( org.antlr.v4.runtime.Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg,
	    org.antlr.v4.runtime.RecognitionException e ) {
		errorCount++;
		this.issues.add( genIssue( line, charPositionInLine, msg, ( Token ) offendingSymbol ) );
	}

	/**
	 * Creates a nicely formatted error message for the user, with the offending source code highlighted
	 *
	 * @param line               the line number where the error occurred
	 * @param charPositionInLine the character position within the line where the error occurred
	 * @param msg                the message generated by the custom error strategy
	 * @param offendingSymbol    the token that caused the error, when it can be identified
	 *
	 * @return
	 */
	private Issue genIssue( int line, int charPositionInLine, String msg, Token offendingSymbol ) {
		String		errorMessage	= msg != null ? msg : "unspecified";
		Position	position		= new Position(
		    new Point( line + startLine, charPositionInLine + startColumn ),
		    new Point( line + startLine, charPositionInLine + startColumn ), sourceToParse );
		return new Issue( errorMessage, position );
	}
}
