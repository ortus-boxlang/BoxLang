/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
package ortus.boxlang.runtime.jdbc.qoq;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;

import ortus.boxlang.compiler.ast.sql.select.SQLSelectStatement;
import ortus.boxlang.runtime.context.IBoxContext;
import ortus.boxlang.runtime.types.Query;

public class QoQStatement implements java.sql.Statement {

	protected IBoxContext	context;
	protected long			maxRows	= -1;
	protected Connection	connection;
	protected Query			result;

	public QoQStatement( IBoxContext context, Connection connection ) {
		this.context	= context;
		this.connection	= connection;
	}

	public ResultSet executeQuery( String sql ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public int executeUpdate( String sql ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public void close() throws SQLException {
	}

	public int getMaxFieldSize() throws SQLException {
		return Integer.MAX_VALUE;
	}

	public void setMaxFieldSize( int max ) throws SQLException {
	}

	public void setLargeMaxRows( long max ) throws SQLException {
		maxRows = max;
	}

	public long getLargeMaxRows() throws SQLException {
		return maxRows;
	}

	public int getMaxRows() throws SQLException {
		return ( int ) maxRows;
	}

	public void setMaxRows( int max ) throws SQLException {
		maxRows = max;
	}

	public void setEscapeProcessing( boolean enable ) throws SQLException {
	}

	public int getQueryTimeout() throws SQLException {
		return 0;
	}

	public void setQueryTimeout( int seconds ) throws SQLException {
	}

	public void cancel() throws SQLException {
	}

	public SQLWarning getWarnings() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public void clearWarnings() throws SQLException {
	}

	public void setCursorName( String name ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public boolean execute( String sql ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public ResultSet getResultSet() throws SQLException {
		throw new UnsupportedOperationException( "Do not call this method.  Since this is a Query of Query statement, use getQueryResult() instead." );
	}

	public Query getQueryResult() {
		return result;
	}

	public int getUpdateCount() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public boolean getMoreResults() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public void setFetchDirection( int direction ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public int getFetchDirection() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public void setFetchSize( int rows ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public int getFetchSize() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public int getResultSetConcurrency() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public int getResultSetType() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public void addBatch( String sql ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public void clearBatch() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public int[] executeBatch() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public Connection getConnection() throws SQLException {
		return connection;
	}

	public boolean getMoreResults( int current ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public ResultSet getGeneratedKeys() throws SQLException {
		return new QoQResultSet();
	}

	public int executeUpdate( String sql, int autoGeneratedKeys ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public int executeUpdate( String sql, int columnIndexes[] ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public int executeUpdate( String sql, String columnNames[] ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public boolean execute( String sql, int autoGeneratedKeys ) throws SQLException {
		// parse the SQL string into an AST object
		SQLSelectStatement select = ( SQLSelectStatement ) QoQExecutionService.parseSQL( sql );

		// execute the query
		result = QoQExecutionService.executeSelectStatement( context, select, this );
		return true;
	}

	public boolean execute( String sql, int columnIndexes[] ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public boolean execute( String sql, String columnNames[] ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	public int getResultSetHoldability() throws SQLException {
		throw new UnsupportedOperationException();
	}

	public boolean isClosed() throws SQLException {
		return false;
	}

	public void setPoolable( boolean poolable ) throws SQLException {
	}

	public boolean isPoolable() throws SQLException {
		return false;
	}

	public void closeOnCompletion() throws SQLException {
	}

	public boolean isCloseOnCompletion() throws SQLException {
		return false;
	}

	@Override
	public <T> T unwrap( Class<T> iface ) throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public boolean isWrapperFor( Class<?> iface ) throws SQLException {
		throw new UnsupportedOperationException();
	}

}
