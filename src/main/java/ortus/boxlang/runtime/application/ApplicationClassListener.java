/**
 * [BoxLang]
 *
 * Copyright [2023] [Ortus Solutions, Corp]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ortus.boxlang.runtime.application;

import ortus.boxlang.runtime.context.ClassBoxContext;
import ortus.boxlang.runtime.context.IBoxContext;
import ortus.boxlang.runtime.context.IBoxContext.ScopeSearchResult;
import ortus.boxlang.runtime.context.RequestBoxContext;
import ortus.boxlang.runtime.dynamic.casters.BooleanCaster;
import ortus.boxlang.runtime.dynamic.casters.StringCaster;
import ortus.boxlang.runtime.runnables.IClassRunnable;
import ortus.boxlang.runtime.scopes.Key;
import ortus.boxlang.runtime.types.Array;
import ortus.boxlang.runtime.types.Function;
import ortus.boxlang.runtime.types.Struct;
import ortus.boxlang.runtime.types.exceptions.AbortException;
import ortus.boxlang.runtime.types.util.BLCollector;
import ortus.boxlang.runtime.util.EncryptionUtil;
import ortus.boxlang.runtime.util.FileSystemUtil;
import ortus.boxlang.runtime.util.ResolvedFilePath;

/**
 * I represent an Application listener that wraps an Application class instance, delegting to it, where possible and providing default
 * implementations otherwise
 */
public class ApplicationClassListener extends BaseApplicationListener {

	/**
	 * Application.bx listener for this request
	 */
	private IClassRunnable listener = null;

	/**
	 * Constructor
	 *
	 * @param listener An Application class instance
	 * @param context  The context to use
	 */
	public ApplicationClassListener( IClassRunnable listener, RequestBoxContext context, ResolvedFilePath baseTemplatePath ) {
		super( context, baseTemplatePath );
		this.listener = listener;

		// Copy all the settings from the Application class to the settings map
		this.settings
		    .putAll( listener.getThisScope().entrySet().stream().filter( e -> ! ( e.getValue() instanceof Function ) ).collect( BLCollector.toStruct() ) );
		this.settings.put( Key.source, listener.getRunnablePath().absolutePath().toString() );
		this.settings.put( Key._CLASS, listener.getRunnablePath().absolutePath().toString() );

		// Expand classPaths in Application.bx. They will be relative to the Application.bx file if not starting with /
		Array classPaths = this.settings.getAsArray( Key.classPaths );
		classPaths = classPaths.stream()
		    .map( String::valueOf )
		    .map( ( cp ) -> {
			    return FileSystemUtil.expandPath( context, cp, listener.getRunnablePath() );

		    } ).collect( BLCollector.toArray() );

		// If there is no application name or if it's empty, make one up.
		String appName = StringCaster.cast( this.settings.get( Key._NAME ) );
		if ( appName == null || appName.isBlank() ) {
			appName = "Autogenerated_Application_Name_" + EncryptionUtil.hash( listener.getRunnablePath().absolutePath().toString() );
			this.settings.put( Key._NAME, appName );
		}

		this.appName = Key.of( this.settings.get( Key._NAME ) );
	}

	/**
	 * Get listener Class instance
	 */
	public IClassRunnable getListenerClass() {
		return listener;
	}

	/**
	 * --------------------------------------------------------------------------
	 * Life-cycle methods
	 * --------------------------------------------------------------------------
	 */

	@Override
	public void onRequest( IBoxContext context, Object[] args ) {
		super.onRequest( context, args );

		if ( listener.getThisScope().containsKey( Key.onRequest ) ) {
			listener.dereferenceAndInvoke( context, Key.onRequest, args, false );
		} else {
			// Default includes template inside the Class's context
			ClassBoxContext cbc = new ClassBoxContext( context, listener );
			try {
				// Ensure our implicit onRequest() always outputs, even if the class has output=false
				cbc.setOutputOverride( true );
				cbc.includeTemplate( ( String ) args[ 0 ] );
				cbc.flushBuffer( false );
			} catch ( AbortException e ) {
				cbc.flushBuffer( false );
				throw e;
			} catch ( Throwable e ) {
				cbc.flushBuffer( false );
				throw e;
			} finally {
				cbc.flushBuffer( false );
				// Reset this override back
				cbc.setOutputOverride( null );
			}
		}
	}

	@Override
	public boolean onRequestStart( IBoxContext context, Object[] args ) {
		super.onRequestStart( context, args );

		if ( listener.getThisScope().containsKey( Key.onRequestStart ) ) {
			Object result = listener.dereferenceAndInvoke( context, Key.onRequestStart, args, false );
			if ( result != null ) {
				return BooleanCaster.cast( result );
			}
			// Null or no return value means true
			return true;
		}
		// Default implementation if there is no Application.bx or it has no onRequestStart method.
		return true;
	}

	@Override
	public void onSessionStart( IBoxContext context, Object[] args ) {
		super.onSessionStart( context, args );

		if ( listener.getThisScope().containsKey( Key.onSessionStart ) ) {
			listener.dereferenceAndInvoke( context, Key.onSessionStart, args, false );
		}
	}

	@Override
	public void onApplicationStart( IBoxContext context, Object[] args ) {
		super.onApplicationStart( context, args );

		if ( listener.getThisScope().containsKey( Key.onApplicationStart ) ) {
			listener.dereferenceAndInvoke( context, Key.onApplicationStart, args, false );
		}
	}

	@Override
	public void onRequestEnd( IBoxContext context, Object[] args ) {
		super.onRequestEnd( context, args );

		if ( listener.getThisScope().containsKey( Key.onRequestEnd ) ) {
			listener.dereferenceAndInvoke( context, Key.onRequestEnd, args, false );
		}
	}

	@Override
	public void onAbort( IBoxContext context, Object[] args ) {
		super.onAbort( context, args );

		if ( listener.getThisScope().containsKey( Key.onAbort ) ) {
			listener.dereferenceAndInvoke( context, Key.onAbort, args, false );
		}
	}

	@Override
	public void onSessionEnd( IBoxContext context, Object[] args ) {
		super.onSessionEnd( context, args );

		if ( listener.getThisScope().containsKey( Key.onSessionEnd ) ) {
			listener.dereferenceAndInvoke( context, Key.onSessionEnd, args, false );
		}
	}

	@Override
	public void onApplicationEnd( IBoxContext context, Object[] args ) {
		super.onApplicationEnd( context, args );

		if ( listener.getThisScope().containsKey( Key.onApplicationEnd ) ) {
			listener.dereferenceAndInvoke( context, Key.onApplicationEnd, args, false );
		}
	}

	@Override
	public boolean onError( IBoxContext context, Object[] args ) {
		super.onError( context, args );

		if ( listener.getThisScope().containsKey( Key.onError ) ) {
			listener.dereferenceAndInvoke( context, Key.onError, args, false );
			return true;
		} else {
			return false;
		}
	}

	@Override
	public boolean onMissingTemplate( IBoxContext context, Object[] args ) {
		super.onMissingTemplate( context, args );

		if ( listener.getThisScope().containsKey( Key.onMissingTemplate ) ) {
			Object result = listener.dereferenceAndInvoke( context, Key.onMissingTemplate, args, false );
			if ( result != null ) {
				return BooleanCaster.cast( result );
			}
			// Null or no return value means false
			return false;
		}
		// Default implementation if there is no Application.bx or it has no onMissingTemplate method.
		return false;
	}

	@Override
	public void onClassRequest( IBoxContext context, Object[] args ) {
		super.onClassRequest( context, args );
		String				className		= ( String ) args[ 0 ];
		Struct				params			= ( Struct ) args[ 1 ];

		IClassRunnable		classInstance	= loadClassInstance( context, className );

		String				methodName		= null;
		ScopeSearchResult	scopeSearch		= context.scopeFind( Key.method, context.getDefaultAssignmentScope(), false );
		if ( scopeSearch.value() != null ) {
			methodName	= StringCaster.cast( scopeSearch.value() );
			args[ 1 ]	= methodName;
		} else {
			classRequestNoMethod( context, classInstance );
			return;
		}
		/*
		 * returnFormat on any onClassRequest method is ignored by both engines
		 * Adobe will look at the returnFormat on the method specified in the URL, EVEN if it's not remote and EVEN if the onClassRequest doesn't delegate to it
		 * Lucee will not use ANY method-based returnFormat when an onClassRequest is present, it appears to always use default, unless the URL override is used
		 * Lucee allows "xml" in addition to Adobe's wddx, json, and plain. Lucee ignores invalid returnFormats, Adobe errors
		 * When using onClassRequest, Adobe will create the CFC twice, presumable once to get the returnFormat from the meta, and a second time in your actual onClassRequest code, assuming you delegate straight through to the original method
		 * Any returnFormat annotation on any other method called during the request is ignored, so long as it wasn't the method specified in the URL
		 * Lucee sets the response content type based on the return format, but Adobe doesn't appear to set any response headers at all based on the return format
		 */
		if ( listener.getThisScope().get( Key.onClassRequest ) instanceof Function ) {
			invokeClassRequest(
			    context,
			    listener,
			    Key.onClassRequest.getName(),
			    null,
			    new Object[] { className, methodName, params, classInstance },
			    false
			);
		} else {
			invokeClassRequest(
			    context,
			    classInstance,
			    methodName,
			    params,
			    null,
			    true
			);
		}
	}

}
